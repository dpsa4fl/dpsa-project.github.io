<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implementation of the generic Fully Linear Proof (FLP) system specified in [draft-irtf-cfrg-vdaf-07]. This is the main building block of `Prio3`."><title>prio::flp - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="prio" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../prio/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../prio/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module flp</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">prio</a>::<wbr><a class="mod" href="#">flp</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/prio/flp.rs.html#3-1059">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implementation of the generic Fully Linear Proof (FLP) system specified in
[<a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-vdaf/07/">draft-irtf-cfrg-vdaf-07</a>]. This is the main building block of <a href="../vdaf/prio3/index.html" title="mod prio::vdaf::prio3"><code>Prio3</code></a>.</p>
<p>The FLP is derived for any implementation of the <a href="trait.Type.html" title="trait prio::flp::Type"><code>Type</code></a> trait. Such an implementation
specifies a validity circuit that defines the set of valid measurements, as well as the finite
field in which the validity circuit is evaluated. It also determines how raw measurements are
encoded as inputs to the validity circuit, and how aggregates are decoded from sums of
measurements.</p>
<h2 id="overview"><a href="#overview">Overview</a></h2>
<p>The proof system is comprised of three algorithms. The first, <code>prove</code>, is run by the prover in
order to generate a proof of a statement’s validity. The second and third, <code>query</code> and
<code>decide</code>, are run by the verifier in order to check the proof. The proof asserts that the input
is an element of a language recognized by the arithmetic circuit. If an input is <em>not</em> valid,
then the verification step will fail with high probability:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>prio::flp::types::Count;
<span class="kw">use </span>prio::flp::Type;
<span class="kw">use </span>prio::field::{random_vector, FieldElement, Field64};

<span class="comment">// The prover chooses a measurement.
</span><span class="kw">let </span>count = Count::new();
<span class="kw">let </span>input: Vec&lt;Field64&gt; = count.encode_measurement(<span class="kw-2">&amp;</span><span class="number">0</span>).unwrap();

<span class="comment">// The prover and verifier agree on &quot;joint randomness&quot; used to generate and
// check the proof. The application needs to ensure that the prover
// &quot;commits&quot; to the input before this point. In Prio3, the joint
// randomness is derived from additive shares of the input.
</span><span class="kw">let </span>joint_rand = random_vector(count.joint_rand_len()).unwrap();

<span class="comment">// The prover generates the proof.
</span><span class="kw">let </span>prove_rand = random_vector(count.prove_rand_len()).unwrap();
<span class="kw">let </span>proof = count.prove(<span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;</span>prove_rand, <span class="kw-2">&amp;</span>joint_rand).unwrap();

<span class="comment">// The verifier checks the proof. In the first step, the verifier &quot;queries&quot;
// the input and proof, getting the &quot;verifier message&quot; in response. It then
// inspects the verifier to decide if the input is valid.
</span><span class="kw">let </span>query_rand = random_vector(count.query_rand_len()).unwrap();
<span class="kw">let </span>verifier = count.query(<span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;</span>proof, <span class="kw-2">&amp;</span>query_rand, <span class="kw-2">&amp;</span>joint_rand, <span class="number">1</span>).unwrap();
<span class="macro">assert!</span>(count.decide(<span class="kw-2">&amp;</span>verifier).unwrap());</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="gadgets/index.html" title="mod prio::flp::gadgets">gadgets</a></div><div class="desc docblock-short">A collection of gadgets.</div></li><li><div class="item-name"><a class="mod" href="types/index.html" title="mod prio::flp::types">types</a></div><div class="desc docblock-short">A collection of <a href="trait.Type.html" title="trait prio::flp::Type"><code>Type</code></a> implementations.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.FlpError.html" title="enum prio::flp::FlpError">FlpError</a></div><div class="desc docblock-short">Errors propagated by methods in this module.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Gadget.html" title="trait prio::flp::Gadget">Gadget</a></div><div class="desc docblock-short">A gadget, a non-affine arithmetic circuit that is called when evaluating a validity circuit.</div></li><li><div class="item-name"><a class="trait" href="trait.Type.html" title="trait prio::flp::Type">Type</a></div><div class="desc docblock-short">A type. Implementations of this trait specify how a particular kind of measurement is encoded
as a vector of field elements and how validity of the encoded measurement is determined.
Validity is determined via an arithmetic circuit evaluated over the encoded measurement.</div></li><li><div class="item-name"><a class="trait" href="trait.TypeWithNoise.html" title="trait prio::flp::TypeWithNoise">TypeWithNoise</a></div><div class="desc docblock-short">A type which supports adding noise to aggregate shares for Server Differential Privacy.</div></li></ul></section></div></main></body></html>